# Vue 3 + TypeScript + Vite

做一个前端项目目录结构设计，注重的是一个结构的设计。在开发的过程中，经常会遇到把什么内容，放在哪个目录下？如何去抽象一个业务，它们之间如何去通讯？觉得这个事情是蛮有趣的，就把它记录下来了。

> 整个过程，并没有原创，标新立异，很多已经是行业的惯例了，更多的是对职责划分的，结构设计的思考过程。

## 项目特点

- 突出特点：注重的是项目的结构设计过程，为什么这样做
- 雏形：这一个项目，不聚焦功能的集成，每个项目需求千差万别，取舍到到什么程度，因项目而异。

## 原则 

- 单一职责：任一目录，都只做一个事情，要有明确的边界
- 集中处理：如一个变量，方法会分散到各个地方，那就要在集中在一个地方处理
- 机制优先：问题千千万，预置解决方案的终归是有限，提供一个解决问题的机制是一个更好的选择，如：中间件，多态，依赖反转


## 项目结构

- api 接口
- config 配置
- pages 页面
- components 组件
- router 路由
- hooks 公用业务逻辑
- store 存储
- utils 工具
  

### api 接口

一个前端，必然要与外界发生数据交互，这样就得有一个目录来承担这个角色。前端目前是通过http协议、websock 与外界进行通讯，当然，绝大多数是用http进行通讯。现在如何去设计这个目录呢？命令一个目录，本质上是在定义问题，定义边界（什么内容应当归到这个目录下）

- 定义：对外界发起请求，如: fetch, ajax 的请求
- 边界：侧重的是请求，如：get, post 发起一个接口请求，像触发请求的动作，获取数据后的处理不可归到本目录中
- 命名：如果叫services，这个职责是比较大，是对pages的页面的具体实现切分才可以，感觉不大合适，当然你这样命名也没有绝对的错对之分。
### 应用说明

边界是定义的再清晰的，也会遇到模糊的时候，需要面对取舍，达到竞争平衡。

#### 有一个接口 getList, 返回数据要进行复杂适配处理才可以被渲染，并且在多个地方被调用，我们来分析一下：

1. 被多个地方调用，根据集中处理原则，应该被抽像到一个地方
2. 适配处理是复杂，应当被抽成一个复用单位，如函数或者类

```ts
// 实际的效果如下：
const adapter = (data: any) => {
  // do something
  return data;
};

export const getList = (params: any, fn: Function = adapter) => {
  return fetch.get('/list', params).then(res => {
    const { data } = res;
    // fn 就是复杂适配的处理函数
    res.data = fn(data);
    return { ...res, data };
  });
};
```


#### 接口与接口之间，有明显的被调用关系，如：接口 getUser 之后要调用 getRole，在多个地方被调用？

- 如一个解码片段，多次重复出现，那么一定有被复用的价值
- 任何复用，都要考虑到定制的多样化。将来不知道什么时候就发生变化了，要提供扩展的能力
- 复用的颗粒度，也要由小到大

```ts
// 小的复用单位
export const getUser = (params: any) => {
  return fetch.get('/user', params);
};

// 小的复用单位
export const getRole = (params: any) => {
  return fetch.get('/role', params);
};

// 组装成一个大的复用单位
export const getRoleByUser = async (params: any) => {
  const user = await getUser({ id: 0 });
  const role = await getRole(user);
  return role
};
```
### config 配置

与环境相关的一个配置信息，为什么要这样一目录，vite 自身就已经集成了 .env.local， .env.[mode].local    

- fetch: 请求后端服务的baseURL
- build: 构建时区分测试，演示，生产环境的一些变量
- ...

### pages 页面

页面，这个就是分发业务，也是一种借鉴后端架构设计的controller。一个页面，集中处理一块业务。有如下明显的边界：

- 必须是一个视图，可见的
- 有一个访问url与之对应的

### components 组件

页面调用的组件，是一个视图组件，有以下特征：

- 必须是一个视图组件，样式独立
- 多个页面调用的，通常颗粒度小于页面

> 任何组件，不得跨页面调用，如A页面调用B页面的组件，这样会发生耦合，且引用关系不清晰。其它影响范围比较大，改动这个组件时，一定要谨慎。
### router 

[路由](https://router.vuejs.org/)：处理页面与url 的映射关系，可以理解为一个空管中心，指挥哪个飞机下落在哪个跑道。

- 指定url 与页面映射关系
- 控制页面的访问权限
### hooks 

页面级的业务逻辑共享，这个也是借鉴后端的service架构设计，有如下的特点：

- 与视图无关，是纯数据的逻辑利用
- 被多个页面共用

### store 
页面数据的共享，与hooks的区别是，这个是数据层面的共享，并且要么在整个应用的生命周期中是不变的，要么是跨页面的通讯

- [存储](https://pinia.vuejs.org/) ：登录信息，权限的共享
### utils 工具

这个是第三方库的集成，进行二次封装，初始化配置。或者是自定义的一些辅助函数，业务的公用函数。

当时有设想过按第三方划分：vendor存放第三方，custom 存放自定义。这样的分类方式，并不是没有接近业务，架构的本质。对于来源什么地方？重要吗? 而是提供什么功能价值，才是用户关心的。也就是实体， 一个一个具体的主题：

- axios：处理http请求
- dayjs：处理日期
- swiper: 处理滑动

### 实体分析

实体就是对一个项目组成进行拆分成要素，一个一个职责明确的主体。如一个电商平台：可以分为买家，卖家，物流，也可以分类商品订单，物流订单，支付。

实体的拆分，体现的是设计者对整个事物的庖丁解牛。架构通讯体现的是实体之间的关联，是一种表达，如同个体与个体之间沟通的手势一样，语言一样。

- 有哪些实体：要如何划分呢
  - 角色扮演：买家，卖家
  - 功能服务：订单，物流单，支付
  
- 实体的关系：
  - 从属关系：如订单中的商品，那么关系构建在订单上，主动发生关联的上面
  - 先后关系：订单 -> 支付 -> 发货，应该记录在起点，也就是订单上

## 集成

在项目中使用第三方库作为一些场景的解决方案，如：router, axios

- UI 组件库: [Naive UI](https://www.naiveui.com/zh-CN/os-theme)
- 路由: [vue router](https://router.vuejs.org/)
- 状态: [pinia](https://pinia.vuejs.org/)
- http 库: [axios](https://github.com/axios/axios)

> 样式的解决方案，推荐css-in-js, 完全组件化

## 推荐 IDE 设置

- [VS Code](https://code.visualstudio.com/) + [Volar](https://marketplace.visualstudio.com/items?itemName=Vue.volar)
